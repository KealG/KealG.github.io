<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>优化UnityUI指南——官方文档翻译与总结</title>
      <link href="2021/02/17/%E4%BC%98%E5%8C%96UnityUI%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>2021/02/17/%E4%BC%98%E5%8C%96UnityUI%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="优化UnityUI指南"><a href="#优化UnityUI指南" class="headerlink" title="优化UnityUI指南"></a>优化UnityUI指南</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CPU片段着色器利用率过高"><a href="#CPU片段着色器利用率过高" class="headerlink" title="CPU片段着色器利用率过高"></a>CPU片段着色器利用率过高</h3><ul><li>填充率过度被使用</li></ul><h3 id="花费大量CPU时间重建Canvas批处理"><a href="#花费大量CPU时间重建Canvas批处理" class="headerlink" title="花费大量CPU时间重建Canvas批处理"></a>花费大量CPU时间重建Canvas批处理</h3><h3 id="画布批处理的重建数量过多"><a href="#画布批处理的重建数量过多" class="headerlink" title="画布批处理的重建数量过多"></a>画布批处理的重建数量过多</h3><ul><li>over-dirtying</li></ul><h3 id="花费过多的CPU时间来生成顶点"><a href="#花费过多的CPU时间来生成顶点" class="headerlink" title="花费过多的CPU时间来生成顶点"></a>花费过多的CPU时间来生成顶点</h3><ul><li>常见于文本问题</li></ul><h3 id="UGUI性能受到发送到GPU的大量绘图调用的限制，但是任何通过绘图调用使GPU过载的项目都更有可能收到填充率过度使用的约束"><a href="#UGUI性能受到发送到GPU的大量绘图调用的限制，但是任何通过绘图调用使GPU过载的项目都更有可能收到填充率过度使用的约束" class="headerlink" title="UGUI性能受到发送到GPU的大量绘图调用的限制，但是任何通过绘图调用使GPU过载的项目都更有可能收到填充率过度使用的约束"></a>UGUI性能受到发送到GPU的大量绘图调用的限制，但是任何通过绘图调用使GPU过载的项目都更有可能收到填充率过度使用的约束</h3><h2 id="UI基础术语及相关概念"><a href="#UI基础术语及相关概念" class="headerlink" title="UI基础术语及相关概念"></a>UI基础术语及相关概念</h2><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><ul><li>原生Unity组件，负责将构成其的几何图形合批，生成适当的渲染命令并将他们发送到unity图形系统</li><li>上述过程被称为一次rebatch或一次batchbuild</li><li>当Canvas被标记为包含需要重新编排的几何图形时，它被认为是dirty的</li><li>Canvas Renderer组件将几何体提供给canvas</li></ul><h3 id="sub-canvas"><a href="#sub-canvas" class="headerlink" title="sub-canvas"></a>sub-canvas</h3><ul><li><p>Sub-Canvas：一个Canvas组件被嵌套在一个Canvas组件里的组件</p></li><li><p>Sub-Canvas将其子对象与其父对象隔离</p><ul><li>隔离以后，dirty的子对象不会强制父对象重建其几何图形，反过来父对象也不会强制子对象重建其几何图形</li><li>但特殊情况若调整父对象Canvas则会重建子对象Canvas的size</li></ul></li></ul><h3 id="Graphic基类"><a href="#Graphic基类" class="headerlink" title="Graphic基类"></a>Graphic基类</h3><ul><li><p>该类是所有UnityUI的基类</p><ul><li>提供Canvas系统可绘制几何图形的能力</li></ul></li><li><p>大多数内置的UnityUI图形是通过MaskableGraphic子类实现的</p><ul><li>提供IMaskable接口允许被遮盖</li></ul></li></ul><h3 id="Layout组件"><a href="#Layout组件" class="headerlink" title="Layout组件"></a>Layout组件</h3><ul><li><p>该组件控制RectTransforms的大小和位置，一般用于创造控制他们所包含对象的相对大小或相对位置的复杂布局</p></li><li><p>该组件仅依赖于RectTransforms，并且仅影响其关联的RectTransforms的属性</p><ul><li>不依赖于Graphic类，因此可以独立于UnityUI的Graphic组件来使用该组件</li></ul></li></ul><h3 id="CanvasUpdateRegistry类"><a href="#CanvasUpdateRegistry类" class="headerlink" title="CanvasUpdateRegistry类"></a>CanvasUpdateRegistry类</h3><ul><li><p>Graphic和Layout都依赖于此类</p></li><li><p>这个类跟踪必须更新的Layout组件和Graphic组件的集合，并且在他们相惯量的Canvas调用WillRenderCanvases事件时根据需要触发更新</p><ul><li>Layout和Graphic组件的更新被称为rebulid</li></ul></li></ul><h3 id="渲染细节"><a href="#渲染细节" class="headerlink" title="渲染细节"></a>渲染细节</h3><ul><li>由UnityUICanvas绘制的所有集合图形都将在“透明”队列中进行绘制，通过其生成的几何图形始终通过alpha混合来从后到前绘制</li><li>性能：从性能角度要记住的重要一点是，即使从多边形栅格化的每个像素都被其他不透明的多边形完全覆盖，也将对其进行采样。在移动设备上，这种较高的透支水平可能会迅速超过Gpu的填充率容量</li></ul><h3 id="Canvas的Batch过程"><a href="#Canvas的Batch过程" class="headerlink" title="Canvas的Batch过程"></a>Canvas的Batch过程</h3><ul><li><p>批处理构建过程是画布将代表其UI元素的网格进行合并，并生成适当的渲染命令以发送到Unity的图形管道，此过程的结果将被缓存并重复使用，一直到Canvas标记为dirty为止</p></li><li><p>当Canvas的组成网格发生变化时，就会出现这种情况</p></li><li><p>Canvas的组成网格取自附加到画布但不包含在任何子画布中的CanvasRender组件</p></li><li><p>计算批次需要按深度对网格进行分类并检查他们是否覆盖，拥有共享材质等</p><ul><li>该操作是多线程的，因此在不同的CPU结构之间，尤其是在移动SoC之间，其性能差异会很大</li></ul></li></ul><h3 id="Graphics的重建过程"><a href="#Graphics的重建过程" class="headerlink" title="Graphics的重建过程"></a>Graphics的重建过程</h3><ul><li><p>该过程会重新计算UnityUI的C#图形组件的布局和网格</p></li><li><p>这个过程在CanvasUpdateRegistry类中执行，开源</p></li><li><p>在CanvasUpdateRegistry中，重点观察的方法是PerformUpdate。每当Canvas组件调用WillRenderCanvases事件时，都会调用此方法，该事件每帧被调用一次</p></li><li><p>工作流程</p><ul><li><p>1.通过ICanvasElement.Rebuild方法，要求dirtyLayout组件重新生成其布局</p><ul><li><p>该过程又分为三个部分</p><ul><li>预布局</li><li>布局</li><li>后布局</li></ul></li></ul></li><li><p>2.要求任何已注册的剪切组件（例如Masks）剔除所有剪切的元素，这是通过ClippingRegistry.Cull完成的</p></li><li><p>3.dirtyGraphic组件被调用来重建其图形元素</p><ul><li><p>该过程又分为两个部分</p><ul><li>预渲染</li><li>后预渲染</li></ul></li></ul></li></ul></li><li><p>Layout重建</p><ul><li>重新计算一个或多个布局组件中包含的组件的适当位置，并且按照其在hierarchical中表现的层级结构顺序应用布局</li><li> 更靠近root根节点的由layout控制的对象更优先改变位置和尺寸，所以应该优先被计算（父变化更少）</li><li>UnityUI将dirty标记的layout组件按其在层次结构中的深度进行排序，层次结构中较高的项目会移到列表的最前面</li><li>该排序列表会被请求以用于重建其布局，这也是实际上更改由布局组件控制的UI元素的位置和大小的地方</li></ul></li><li><p>Graphic重建</p><ul><li><p>当Graphic元素被重建时，UnityUI将控制权传递给ICanvasElement接口的Rebuild方法</p></li><li><p>Graphic通过两个步骤在重建过程的预渲染阶段实现</p><ul><li>如果顶点数据被标记为dirty，则重新构建mesh网格数据(例如当组件的RectTransform大小更改时)</li><li>如果材质数据被标记为dirty(当组件对象的材质或纹理发生变化时)，则将更新附加的CanvasRenderer将被更新</li><li>Graphic重建不会以任何特定顺序遍历图形组件列表，并且不需要任何排序的操作</li></ul></li></ul></li></ul><h2 id="UnityUIProfilingTools"><a href="#UnityUIProfilingTools" class="headerlink" title="UnityUIProfilingTools"></a>UnityUIProfilingTools</h2><h3 id="毫秒-方法级性能分析外部扩展工具"><a href="#毫秒-方法级性能分析外部扩展工具" class="headerlink" title="毫秒-方法级性能分析外部扩展工具"></a>毫秒-方法级性能分析外部扩展工具</h3><h3 id="UnityProfiler"><a href="#UnityProfiler" class="headerlink" title="UnityProfiler"></a>UnityProfiler</h3><ul><li><p>CPU探查器模块</p><ul><li><p>主要用途：执行比较概要分析</p></li><li><p>在运行时启用和禁用UI元素可以迅速缩小UI层次结构中最引起性能问题的部分</p></li><li><p>注意观察Canvas.BuildBatch和Canvas.SendWillRenderCanvases</p><ul><li><p>Canvas.BuildBatch</p><ul><li>Canvas执行批处理构建过程的本机代码计算消耗</li></ul></li><li><p>Canvas.SendWillRenderCanvasess</p><ul><li>Canvas.SendWillRenderCanvasess包含了对Canvas组件的willRenderCanvases事件订阅的C#脚本的调用，UI的CanvasUpdateRegistry类接受到此事件，并使用它来进行重建过程</li></ul></li></ul></li></ul></li><li><p>UI探查器模块</p><ul><li><p>第一个时间轴显示在两个类别上所花费的CPU事件</p></li><li><p>第二个时间轴显示批处理，顶点的总数并显示事件标记</p></li><li><p>*批处理查看器</p><ul><li><p>能够查看所有画布的树状视图</p><ul><li>有助于更好的了解如何优化UI及批处理中断原因</li></ul></li><li><p>常见出现中断批次问题原因</p><ul><li>使用了不同纹理或材质的UI元素</li></ul></li><li><p>常见解决方法</p><ul><li>使用图集与（参考网上动态打图集做法）</li></ul></li></ul></li></ul></li></ul><h3 id="UnityFrameDebugger"><a href="#UnityFrameDebugger" class="headerlink" title="UnityFrameDebugger"></a>UnityFrameDebugger</h3><ul><li><p>可以Debug以减少UnityUI生成的绘图调用的次数</p></li><li><p>Tips：基于EditorGameView绘制调用进行更新，所以可以在不进入播放模式下进行调试</p></li><li><p>UnityUI绘制调用的位置取决于在绘制的Canvas组件上选择的渲染模式</p><ul><li><p>屏幕空间-覆盖</p><ul><li>将出现在Canvas.RenderOverlays组中</li></ul></li><li><p>屏幕空间-摄影机</p><ul><li>将出现在选定摄影机的Camera.Render组件中</li></ul></li><li><p>世界空间</p><ul><li>将出现在可见画布的每个世界空间摄像机的Render.TransparentGeometry子组</li></ul></li></ul></li><li><p>通过这种方式可以实时调试并观察分析结果，最大化Canvas将UI元素组合为批处理的过程</p></li><li><p>常见问题</p><ul><li>意外或非必要的重叠</li></ul></li><li><p>问题产生的根本原因</p><ul><li><p>UnityUI完全在透明队列中运行，必须在不可合批的四边形被覆盖之前绘制出该不可合批的四边形</p><ul><li>举例：考虑三个四边形（A、B和C）他们相互重叠，但是AC拥有相同的材质，B使用单独的材质，所以B和AC不能合批处理</li><li>如果从上到下是A，B,C,则无法批处理A和C，因为B必须在AC的中间绘制（3次），但是若将B放在AC的前面或者后面那么就是(2次)</li></ul></li></ul></li></ul><h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><ul><li><p>Canvas.BuildBatch()或Canvas.UpdateBatches()使用了过多的CPU时间</p><ul><li><p>大概率问题可能是单个Canvas上的CanvasRender组件数量过多</p><ul><li>参阅Canvas中分割Canvas部分内容</li></ul></li></ul></li><li><p>IndexedSet_Sort()与CanvasUpdateRegistry_SortLayoutList()花费过多WillRenderCanvas占比时间</p><ul><li><p>花费过多时间对dirty标记组件列表进行排序</p><ul><li>减少Canvas上layout组件的数量，参考使用RectTransforms替换Layout 和拆分画布部分以获取可能的补救措施</li></ul></li></ul></li><li><p>Text_OnPopulateMesh花费过多时间</p><ul><li><p>BestFit与DisablingCanvasessections</p><ul><li>考虑切分Canvases如果正在重建的文本灭有更改基础字符串部分</li></ul></li></ul></li><li><p>Shadow_ModifyMesh或者Outline_ModifyMesh(ModifyMesh之下其他的实现)花费过多时间</p><ul><li><p>花费太多时间计算修改网格渲染器</p><ul><li>考虑移除这些组件并通过静态图像实现其视觉效果</li></ul></li></ul></li><li><p>如果没有特别的热点或是Canvas.SendWillRenderCanvases每帧都在执行</p><ul><li><p>动静组件未分离</p><ul><li>考虑分割Canvas并进行动静分离</li></ul></li></ul></li></ul><h3 id="Instruments和VTune对Apple和IntelCPU上的UnityUI重建和Canvas批处理进行深入分析"><a href="#Instruments和VTune对Apple和IntelCPU上的UnityUI重建和Canvas批处理进行深入分析" class="headerlink" title="Instruments和VTune对Apple和IntelCPU上的UnityUI重建和Canvas批处理进行深入分析"></a>Instruments和VTune对Apple和IntelCPU上的UnityUI重建和Canvas批处理进行深入分析</h3><ul><li>暂略</li></ul><h2 id="更广泛的UnityUI问题Fill-rate-Canvas和input"><a href="#更广泛的UnityUI问题Fill-rate-Canvas和input" class="headerlink" title="更广泛的UnityUI问题Fill-rate,Canvas和input"></a>更广泛的UnityUI问题Fill-rate,Canvas和input</h2><h3 id="修复填充率问题"><a href="#修复填充率问题" class="headerlink" title="修复填充率问题"></a>修复填充率问题</h3><ul><li><p>降低片段着色器的复杂性，详细参考“UI着色器和低规格设备”部分</p></li><li><p>减少必须采样的像素数</p></li><li><p>消除不可见的用户界面</p><ul><li><p>禁用不可见的UI元素</p><ul><li>当打开具有不透明的全屏UI时，在这种情况下，可以禁用放置于全屏UI下方的任何UI元素。</li><li>最简单的操作即禁用包含不可见UI元素的根GameObject</li><li>通过将Alpha设置为0，确保没有UI元素被隐藏，因为被隐藏的该元素仍然将发送到GPU</li><li>如果UI元素不需要图形组件，则只需要将其删除，光纤投射仍然将起作用</li></ul></li></ul></li><li><p>简化UI结构</p><ul><li><p>减少重建和呈现UI所需的时间</p><ul><li>使UI对象的数量尽可能地少，尝试尽可能多的烘培物体</li></ul></li></ul></li><li><p>禁用隐形摄像机输出</p><ul><li><p>禁用不可见的场景对象</p><ul><li>当打开了具有不透明背景的全屏UI，则世界空间渲染场景的相机不知道这一情况，仍然在工作，而这无异于浪费宝贵的GPU资源</li><li>根据需求可将最后一帧画面给RawImage表现来优化性能</li></ul></li></ul></li><li><p>合成UI</p><ul><li><p>创建专门的UISprite，这些Sprite合成了尽可能多的不可变元素到其背景纹理中</p><ul><li>尽可能节省填充消耗</li></ul></li></ul></li><li><p>优化UI着色器</p><ul><li>针对低端设备按需求优化或自定义UI着色器，比如若低端设备上不需要遮罩剪辑和其他“复杂”功能，可以创建一个自定义着色器以忽略那些在项目中从未使用到的操作</li></ul></li></ul><h3 id="UICanvas重建（Rebuild）"><a href="#UICanvas重建（Rebuild）" class="headerlink" title="UICanvas重建（Rebuild）"></a>UICanvas重建（Rebuild）</h3><ul><li><p>运行动态布局代码</p></li><li><p>生成多边形以表示UI文本</p></li><li><p>将尽可能多的几何图形合批到单个网格中，以最大程度减少绘制调用</p></li><li><p>常见性能问题</p><ul><li>如果单个Canvas上待绘制UI元素数量很大，计算批处理这个过程就会消耗很大，因为对这些元素排序和分析的成本增长速度超出了线性范围</li><li>如果单个Canvas经常被修改标记为dirty，则会花费大量时间来刷新</li><li>Tips:每当给定Canvas上的任何可绘制UI元素发生更改时，Canvas都必须重新运行批处理构建过程，这个过程会重新分析Canvas上每个待绘制的UI元素无论它是否被修改。（这里的修改包括了分配给sprite渲染器的sprite，位置和比例，文本网格中包含的文本等）</li></ul></li><li><p>子对象规则</p><ul><li><p>UnituUI是根据对象在hierarchy中的排序从后到前构造，排序越前的对象会比靠后的对象先构造</p></li><li><p>通过从上到下遍历层级结构并收集使用相同材料与纹理的对象集合构建批次，但若出现了放置在两个可同批次处理对象之间的“中间层”，那么他们的合批就会被破坏</p></li><li><p>优化操作</p><ul><li>打开Frame Debug调整可绘制对象的顺序，以使可批处理对象们确保他们都被正常的合批处理未被意外的“中间层”打断，可将“中间层”调整至可合批的上方或者下方</li><li>还可以通过调整对象的位置，直接消除不可见的重叠空间</li></ul></li></ul></li><li><p>分割画布</p><ul><li><p>除了特别琐碎的情况之外，拆分画布通常是一个好主意</p></li><li><p>同级画布通常最适合在某些UI部分必须始终与该UI其余部分分开控制深度以始终让它位于其他层之上或之下的情况使用</p></li><li><p>在大多数情况下，子画布更方便，因为其继承了父画布的一些显示设置</p></li><li><p>要设计出一个高性能的UI则需要在控制最小重建成本与控制最小化浪费的绘制调用之间取得平衡</p></li><li><p>一般情况</p><ul><li>Canvas会在其组成的可绘制组件中的任何一个发生更改的任何时候重新绘制，所以建议将任何不重要的Canvas分成至少两个部分，将那些需要同时更改的Canvas放置在同一个Canvas上。</li><li>例如进度条与倒数计时器，放置在一个画布上，在另外一个画布上，放置所有静态且不变的元素，例如背景与标签。（主要还是确保动静分离避免无意义重绘，确保重绘主要是dirty标记元素）</li></ul></li></ul></li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li><p>Unity中的输入与射线计算</p><ul><li><p>GraphicRaycaster迭代所有将RaycastTarget设置为true的Graphic组件，对于每个RaycastTarget，都会执行一组测试，如果RaycastTarget通过了所有测试，则它被添加到匹配列表中。</p></li><li><p>检测步骤</p><ul><li>如果RaycastTarget勾选对象启用且被绘制</li><li>如果输入点位于附加了RaycastTarget组件的对象的RectTransform中</li><li>如果该对象或其父对象实现了ICanvasRaycastFilter并且该接口允许进行Raycast</li></ul></li><li><p>结果</p><ul><li>命中的RaycastTargets列表根据深度进行排序，过滤掉背对的目标，过滤掉渲染在相机后面元素(即屏幕不可见)</li><li>如果启用了2D或3D阻挡对象，则在射线阻挡物理层上2D或3D对象下方绘制的所有射线阻挡目标也将从命中列表中消除</li><li>返回结果</li></ul></li><li><p>优化技巧</p><ul><li>1.仅在必须接受指针时间的UI组件上启用RaycastTarget设置，尽可能缩小射线广播目标的列表长度，并且遍历的层次越浅，则每个射线广播测试会越快</li><li>2.对于多个必须响应鼠标指针事件的可绘制UI对象的复合UI控件，最好将单个RaycastTarget放置在根节点控制，通过根节点转发指针事件到复合控件中对该消息感兴趣的组件中</li></ul></li><li><p>场景层次深度和射线计算过滤器</p><ul><li>每一个GraphicRaycaster遍历hierarchy中所有transform去搜索raycastfilters，该搜索操作是随着场景中对象的深度呈线性增长，因为必须测试每个与Transform关联的所有组件，以查看他们是否实现了ICanvasRaycastFilter，所以这个操作也很耗时间。因为有几个使用了ICanvasRaycastFilter的标准UnityUI组件，例如CanvasGroup，Image，Mask和RectMask2D,因此不能轻易消除这种遍历</li></ul></li><li><p>子画布和OverrideSorting属性</p><ul><li>子画布上的overrideSorting属性将会导致图形射线计算停止向上搜索transform，如果启用它不会带来层级排序和射线检测问题，那么这时候就应该使用它来降低射线计算在场景中的遍历搜索过滤器消耗</li></ul></li></ul></li></ul><h2 id="优化特定UI控件"><a href="#优化特定UI控件" class="headerlink" title="优化特定UI控件"></a>优化特定UI控件</h2><h3 id="重点介绍某些特定类型UI控件常见的问题"><a href="#重点介绍某些特定类型UI控件常见的问题" class="headerlink" title="重点介绍某些特定类型UI控件常见的问题"></a>重点介绍某些特定类型UI控件常见的问题</h3><h3 id="UIText"><a href="#UIText" class="headerlink" title="UIText"></a>UIText</h3><ul><li><p>文本字形实际上是以单个四边形呈现的，每个字符一个，根据字体的形状，这些四边形往往会在字形周围具有大量空白空间，这很容易在无意中破坏了其他UI元素的批处理</p></li><li><p>问题</p><ul><li><p>文字网格频繁重建问题</p><ul><li>主要的问题体现在UI文本网格的重建过程，每当更改UIText组件时，该文本组件都必须重新计算用于显示实际文本的多边形，就算仅禁用与启用其文本组件或其任何父GameObject没有更改，也会重新计算</li><li>在显示大量文本的用户界面时，这种行为都是有问题的，因此针对于复杂文本显示的场景用来控制其隐藏与显示的方法不能是启用或禁用包含该UI的GameObject</li></ul></li><li><p>显示字符集很大或运行之前未知</p></li><li><p>存在公用字形情况</p></li></ul></li><li><p>解决方法</p><ul><li><p>文字网格频繁重建问题</p><ul><li>通过禁用CanvasSession来控制显示与否</li></ul></li><li><p>显示字符集很大或运行之前未知</p><ul><li>动态字体和字体图集</li></ul></li><li><p>存在公用字形情况</p><ul><li>编写自定义组件以显示这些字形的子画面会比Canvas驱动的UIText组件更快的计算创建动画与显示</li></ul></li></ul></li><li><p>*BestFit选项</p><ul><li>通常情况下，最好不要使用UIText组件的BestFit选项因为其性能开销过大</li></ul></li></ul><h3 id="TextMeshPro"><a href="#TextMeshPro" class="headerlink" title="TextMeshPro"></a>TextMeshPro</h3><ul><li>TextMeshPro使用符号距离字段作为其主要的文本渲染管道，从而可以在任何大小和分辨率下清晰地渲染文本，现在已经替代了Unity现有的文本组件</li><li>文字网格重建</li><li>字体和内存使用情况</li></ul><h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3><ul><li><p>滚动视图的性能问题是在填充率问题之后的第二大常见运行时性能问题</p></li><li><p>问题常出现在填充滚动视图</p><ul><li><p>用代表所有滚动视图内容的所有必要元素填充它</p><ul><li>随着要表示的项目数增加而需要更多的时间来实例化所有UI元素</li></ul></li><li><p>合并元素，根据需要重新定位它们以表示可见内容</p><ul><li>需要大量代码才能在当前的UI和布局系统下正确实现</li></ul></li><li><p>对于任何非常复杂的滚动UI，通常都需要某种池化的方法来避免性能问题</p></li><li><p>这里所有的表现问题都能通过添加一个RectMask2D来改进</p><ul><li>该组件确保在滚动画布的视口外的滚动视图元素不包含在可绘制元素的列表中。而这些元素在重建Canvas时必须生成，排序和分析其几何形状会带来性能消耗</li></ul></li></ul></li><li><p>常用解决方法</p><ul><li><p>使用带有LayoutElement组件的GameObject作为可见UI元素的“占位符”</p></li><li><p>实例化UI元素池，该池所包含元素足够填充ScrollView的可见区域，在滚动视图时，重复使用UI元素以显示滚动到视图中的内容</p></li><li><p>这大大减少了UI合批的次数，因为合批的花销仅仅跟Canvas中CanvasRenderers数量有关而非其RectTransforms的数量有关</p></li><li><p>带来的问题：每当重设UI元素或更改其兄弟元素顺序时，该元素及其所有子元素都将标记为dirty，并强制对其Canvas进行重建</p><ul><li>Unity并未分离用于重构transform与更改其同级兄弟顺序的回调，他们都会触发OnTransformParentChanged回调，在Graphic类的源代码中，该回调实现并调用方法SetAllDirty</li><li>解决方法：将画布分配给ScrollView中每个元素的根RectTransform，这将把重建限制在仅父元素而不是ScrollView的全部内容中，但是这样又会增加渲染这个滚动视图所需要的绘制调用次数</li><li>第二个解决方法：如果ScrollViewUI元素的大小不可变，则不需要对布局和顶点进行完全重新计算，那么我们就需要实现一个基于其元素位置更改而不是父级或同级顺序更改的对象池解决方案</li></ul></li><li><p>基于位置的滚动视图池</p><ul><li>通过创建一个简单地移动其包含的UI元素的RectTransform的对象池来避免在没有修改尺寸的情况下重建RectTransforms内容，从而提高了ScrollView的性能</li><li>可以通过编写一个ScrollView的自定义子类或编写一个自定义的LayoutGroup组件，后者通常更为简单，可以通过实现UnityUI的LayoutGroup抽象基类的子类来实现</li><li>自定义LayoutGroup可以分析基础源数据来检查必须显示多少个数据元素。可以适当调整ScrollView的ContentRectTransform的大小，然后通过订阅ScrollView更改时间，并使用这些时间相应地重新定位其可见元素</li></ul></li></ul></li></ul><h2 id="其他UI优化技术与技巧"><a href="#其他UI优化技术与技巧" class="headerlink" title="其他UI优化技术与技巧"></a>其他UI优化技术与技巧</h2><h3 id="这里有一些优化技巧可能会在结构上显得“不干净”，可能变得难以维护，可能是在UI中的一些简化初始开发的行为"><a href="#这里有一些优化技巧可能会在结构上显得“不干净”，可能变得难以维护，可能是在UI中的一些简化初始开发的行为" class="headerlink" title="这里有一些优化技巧可能会在结构上显得“不干净”，可能变得难以维护，可能是在UI中的一些简化初始开发的行为"></a>这里有一些优化技巧可能会在结构上显得“不干净”，可能变得难以维护，可能是在UI中的一些简化初始开发的行为</h3><h3 id="基于RectTransform的布局"><a href="#基于RectTransform的布局" class="headerlink" title="基于RectTransform的布局"></a>基于RectTransform的布局</h3><ul><li><p>布局组件消耗相对较大，因为布局组件每次标记为dirty时必须重新计算其子元素的大小和位置，如果给定布局中元素的数量相对较小且固定，并且布局具有相对简单的结构，则可以通过基于RectTransfrom锚点布局进行替换</p></li><li><p>例如，可以使用两个RectTransforms实现简单的两列布局</p><ul><li>左列的锚点应为：X:(0,0.5)和Y(0,1)</li><li>右列的锚点应为：X:(0.5,1)和Y(0,1)</li></ul></li><li><p>RectTransform的大小和位置的计算将由Transform系统原生代码进行计算，通常这比依赖Layout系统的性能更高，也可以编写MonoBehaviours来设置基于RectTransform的布局，但这相对复杂</p></li></ul><h3 id="禁用画布"><a href="#禁用画布" class="headerlink" title="禁用画布"></a>禁用画布</h3><ul><li>一般当需要显示或隐藏UI的零散部分时，我们会在UI的根部启用或禁用GameObject，这样可以确保禁用的UI中的任何组件都不会接受输入或Unity回调</li><li>但是这也导致了Canvas放弃其VBO数据，重新启用对象画布时需要运行重建和重新批处理过程，这种情况如果经常发生，则会导致CPU使用率增加进而导致帧率降低</li><li>*考虑将要显示/隐藏的UI放置在其自己的Canvas或Sub-Canvas上，然后尽在此对象上启用/禁用Canvas组件</li><li>这回导致不绘制UI的网格，但是他们将保持驻留在内存中，并且将保留其原始批处理，此外将不会再UI的层次结构中调用OnEnable或OnDisable回调</li><li>*但是，这不会禁用隐藏UI中的任何MonoBehaviors，因此这些MonoBehaviours仍将接受Unity的生命周期回调，例如Update</li><li>因此，为了避免这个问题，采用这种方式禁用UI上的MonoBehaviours不应直接实现Unity的生命周期回调，而应该从UI根GameObject上的“回调管理器”Mono Behaviour接受其回调，每当显示/隐藏UI时，通知此回调管理器，可以确保根据需要传播或不传播生命周期事件，有关回调管理器的模式，请自行认真考虑</li></ul><h3 id="分配事件摄像机"><a href="#分配事件摄像机" class="headerlink" title="分配事件摄像机"></a>分配事件摄像机</h3><ul><li>如果使用Unity的内置输入管理器并且Canvases设置渲染WorldSpace或者ScreenSpace-Camera模式，那么请一定要分别设置事件摄像机或渲染摄像机属性，在脚本中都称之为worldCamera属性</li><li>如果不设置的话，那么每打开一个WorldSpace或者CameraSpace的Canvas都会默认通过maincamera标签搜索附加了camera组件的游戏对象</li><li>因此，强烈建议在所有WorldSpace和CameraSpace的Canvas初始化时分配其Camera属性</li><li>Overlay模式的Canvases不会发生此问题</li></ul><h3 id="UI源代码定制"><a href="#UI源代码定制" class="headerlink" title="*UI源代码定制"></a>*UI源代码定制</h3><ul><li>略</li></ul><h2 id="实际操作（项目中实际进行的一些操作，持续补充更新中…）"><a href="#实际操作（项目中实际进行的一些操作，持续补充更新中…）" class="headerlink" title="实际操作（项目中实际进行的一些操作，持续补充更新中…）"></a>实际操作（项目中实际进行的一些操作，持续补充更新中…）</h2><h3 id="UIText的字体文件引用同一个"><a href="#UIText的字体文件引用同一个" class="headerlink" title="UIText的字体文件引用同一个"></a>UIText的字体文件引用同一个</h3><h3 id="图片应用同一图集"><a href="#图片应用同一图集" class="headerlink" title="图片应用同一图集"></a>图片应用同一图集</h3><h3 id="注意相对层级结构"><a href="#注意相对层级结构" class="headerlink" title="注意相对层级结构"></a>注意相对层级结构</h3><h3 id="当启用了Mask组件结合自动布局组件使用时，注意mask边界情况Batches的处理，根据需要调优"><a href="#当启用了Mask组件结合自动布局组件使用时，注意mask边界情况Batches的处理，根据需要调优" class="headerlink" title="当启用了Mask组件结合自动布局组件使用时，注意mask边界情况Batches的处理，根据需要调优"></a>当启用了Mask组件结合自动布局组件使用时，注意mask边界情况Batches的处理，根据需要调优</h3><h3 id="ScrollView中使用RectMask2D替换Mask"><a href="#ScrollView中使用RectMask2D替换Mask" class="headerlink" title="ScrollView中使用RectMask2D替换Mask"></a>ScrollView中使用RectMask2D替换Mask</h3>]]></content>
      
      
      <categories>
          
          <category> Game Engine </category>
          
          <category> Unity </category>
          
          <category> UI(UGUI) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> UI </tag>
            
            <tag> UNITY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机程序的构造和解释</title>
      <link href="2021/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/"/>
      <url>2021/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机程序的构造和解释"><a href="#计算机程序的构造和解释" class="headerlink" title="计算机程序的构造和解释"></a>计算机程序的构造和解释</h1><h2 id="第一章：构造过程抽象"><a href="#第一章：构造过程抽象" class="headerlink" title="第一章：构造过程抽象"></a>第一章：构造过程抽象</h2><h3 id="“define-“-LISP"><a href="#“define-“-LISP" class="headerlink" title="“define “(LISP)"></a>“define “(LISP)</h3><ul><li>关联值与符号</li><li>关联过程与符号</li></ul><h3 id="应用序和正则序"><a href="#应用序和正则序" class="headerlink" title="应用序和正则序"></a>应用序和正则序</h3><h3 id="条件表达式和谓词"><a href="#条件表达式和谓词" class="headerlink" title="条件表达式和谓词"></a>条件表达式和谓词</h3><hr><h1 id="待更新中…"><a href="#待更新中…" class="headerlink" title="待更新中…."></a>待更新中….</h1>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
          <category> 编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程快速上手指南</title>
      <link href="2021/02/17/%E5%B7%A5%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"/>
      <url>2021/02/17/%E5%B7%A5%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="工程快速上手指南"><a href="#工程快速上手指南" class="headerlink" title="工程快速上手指南"></a>工程快速上手指南</h1><h2 id="1-阅读组内基本说明文档，脑内构建大致框架与流程"><a href="#1-阅读组内基本说明文档，脑内构建大致框架与流程" class="headerlink" title="1.阅读组内基本说明文档，脑内构建大致框架与流程"></a>1.阅读组内基本说明文档，脑内构建大致框架与流程</h2><h2 id="2-根据自己近期需要接触的功能项，重点看已有案例，若时间空隙，尽量结合断点调试与自己尝试模仿重写案例"><a href="#2-根据自己近期需要接触的功能项，重点看已有案例，若时间空隙，尽量结合断点调试与自己尝试模仿重写案例" class="headerlink" title="2.根据自己近期需要接触的功能项，重点看已有案例，若时间空隙，尽量结合断点调试与自己尝试模仿重写案例"></a>2.根据自己近期需要接触的功能项，重点看已有案例，若时间空隙，尽量结合断点调试与自己尝试模仿重写案例</h2><h3 id="1-Debug能力"><a href="#1-Debug能力" class="headerlink" title="1.Debug能力"></a>1.Debug能力</h3><h3 id="2-解构工程"><a href="#2-解构工程" class="headerlink" title="2.解构工程"></a>2.解构工程</h3><ul><li>1.数据的输入（策划表、网络数据等）</li><li>2.Prefab等资源加载方式（预置体、美术资源等）</li><li>3.关于数据组织的常规流程结构，各个生命周期的回调</li><li>4.熟悉工程内已有通用功能函数等，避免重复造轮子同时提高开发效率</li><li>5.多断点调试尝试输出或展示自己的功能制作结果</li></ul><h3 id="3-上手写功能"><a href="#3-上手写功能" class="headerlink" title="3.上手写功能"></a>3.上手写功能</h3><ul><li><p>如何设计功能结构？</p></li><li><p>常见的MVC结构</p><ul><li><p>M模型</p><ul><li>负责组织数据结构也就是业务向的数据处理流程等，并对外提供GetData（）、SetData（）的接口</li></ul></li><li><p>V视图</p><ul><li>提供视图层的封装与组装，针对于游戏业务还可以有视图层的生命周期回调</li></ul></li><li><p>C控制器</p><ul><li>处理View层传回用户交互数据与M层相关处理逻辑，并控制模型选择最终展示的v层细节，一般情况下，C层也是入口程序点，它负责了选择要使用的模型类型和要呈现的视图</li></ul></li></ul></li></ul><h2 id="3-正式开发功能demo前，需要对组内开发规范做到心中有数，避免错误的开发行为"><a href="#3-正式开发功能demo前，需要对组内开发规范做到心中有数，避免错误的开发行为" class="headerlink" title="3.正式开发功能demo前，需要对组内开发规范做到心中有数，避免错误的开发行为"></a>3.正式开发功能demo前，需要对组内开发规范做到心中有数，避免错误的开发行为</h2><hr><h1 id="待更新中…"><a href="#待更新中…" class="headerlink" title="待更新中…"></a>待更新中…</h1>]]></content>
      
      
      <categories>
          
          <category> 工程向 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shader入门精要</title>
      <link href="2021/02/17/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"/>
      <url>2021/02/17/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Shader入门精要"><a href="#Shader入门精要" class="headerlink" title="Shader入门精要"></a>Shader入门精要</h1><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><h3 id="应用阶段（CPU和GPU之间的通信）"><a href="#应用阶段（CPU和GPU之间的通信）" class="headerlink" title="应用阶段（CPU和GPU之间的通信）"></a>应用阶段（CPU和GPU之间的通信）</h3><ul><li><p>准备场景数据，剔除不可见模型，设置每个模型的渲染状态，例如它使用的材质、使用的纹理、使用的shader等。最后输出渲染所需的几何信息，即渲染图元</p></li><li><p>起点是CPU，大致分为以下三个阶段</p><ul><li><p>1.将数据加载到显存中</p><ul><li>所有渲染所需的数据需要从硬盘中加载到系统内存中，然后网格、纹理、顶点的位置信息、法线方向、顶点颜色和纹理坐标等数据又被加载到显存中。（显存访问更快且大多数显卡不能直接访问RAM）</li><li>加载到显存中后，RAM中的数据就可以移除了，但对于一些数据来说，CPU仍然需要访问他们。（例如CPU需要访问网格数据来进行碰撞检测）</li></ul></li><li><p>2.设置渲染状态</p><ul><li>这些状态定义了场景中的网格是怎样被渲染的。例如使用了哪个顶点着色器、片元着色器、光源属性、材质等</li></ul></li><li><p>3.调用DrawCall</p><ul><li>CPU向GPU发出的绘制指令</li><li>当给定了一个DrawCall时，GPU根据渲染状态（例如材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的那些像素</li></ul></li></ul></li></ul><h3 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h3><ul><li><p>负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。这个阶段最重要的任务是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理以后，这一阶段会输出屏幕的二维顶点坐标，每个顶点对应深度值、着色等信息，并将这些信息传递给下一个阶段</p></li><li><p>接受顶点数据作为输入，这些数据是由应用阶段加载到显存中的，再由DrawCall指定的。这些数据随后被传递给顶点着色器</p><ul><li><p>顶点着色器（可编程）</p><ul><li><p>顶点的空间变换、顶点的着色等功能</p><ul><li>顶点着色器是流水线的第一个阶段，其输入来自于CPU，本身不可以创建或者销毁任何顶点，并且无法得到顶点与顶点之间的关系，处理单位是顶点</li></ul></li><li><p>详细</p><ul><li><p>坐标变换</p><ul><li>对顶点的坐标进行某种变换，顶点着色器可以在这一步改变顶点的位置，这在顶点动画中十分有用。例如可以通过改变顶点位置模拟水面、布料等。</li><li>必须完成的最基本的工作是：把顶点坐标从模型空间转换到齐次裁剪空间。</li></ul></li></ul></li></ul></li><li><p>*曲面细分着色器（可编程）</p><ul><li>用于细分图元</li></ul></li><li><p>*几何着色器（可编程）</p><ul><li>逐图元的着色操作，或者产生更多图元</li></ul></li><li><p>裁剪（可配置）</p><ul><li><p>将不在摄像机是业内的顶点裁剪掉，并剔除某些三角图元的面片</p><ul><li>已知在NDC下的顶点坐标，其顶点位置在一个立方体内，只需要将图元裁剪到单位立方体内</li><li>这一步无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置</li></ul></li></ul></li><li><p>屏幕映射（不可配置与编程的）</p><ul><li><p>负责把每个图元的坐标转换到屏幕坐标系中</p><ul><li>这一步的输入坐标仍然是三维坐标系下的坐标（范围在单位立方体内）。屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系下，屏幕坐标系是一个二维坐标系，和我们用于显示画面的分辨率有很大关系。</li><li>实际上，屏幕坐标系和z坐标一起构成了一个坐标系，叫做窗口坐标系。这些值会一起被传递到光栅化阶段</li><li>*小心OpenGL与DirectX窗口坐标系的差异，前者是以左下角为原点，后者是以左上角为原点的</li></ul></li></ul></li></ul></li></ul><h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><ul><li><p>这个阶段使用几何阶段传递过来的二维顶点坐标来产生屏幕上的像素，并渲染出最终的图像。光栅化的任务主要是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。需要对上一个阶段得到的逐顶点数据（例如纹理坐标、顶点颜色）进行插值，然后进行逐像素处理</p></li><li><p>接受上一个阶段输出得信息是屏幕坐标系下的顶点位置以及和他们相关的额外信息，例如深度值、法线方向、视角方向等。光栅化阶段的两个重要目标分别是：1.计算每个图元覆盖了哪些像素.2.为这些像素计算他们的颜色</p><ul><li><p>三角形设置（不可编程与配置）</p><ul><li>计算光栅化一个三角形网格所需的信息，比如将上阶段提交过来的在屏幕空间坐标系下顶点的数据计算其所覆盖的像素情况。这样一个计算三角形网格表示数据的过程就叫做三角形设置，它的输出是为了给下一个阶段做准备</li></ul></li><li><p>三角形遍历（不可编程与配置）</p><ul><li>该阶段会检查每个像素是否被一个三角形网格所覆盖，如果覆盖的话就会生成一个片元，这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换</li><li>输出是一个片元序列，一个片元包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了它的屏幕坐标、深度信息，以及其他从几何阶段输出的顶点信息，例如法线、纹理坐标等</li></ul></li><li><p>*片元着色器（可编程）</p><ul><li>实现逐片元的着色操作</li><li>该阶段的输入是上一个阶段对定点信息插值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。而它的输出是一个或者多个颜色值</li><li>该阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样</li></ul></li><li><p>逐片元操作（不可编程但可配置）</p><ul><li><p>修改颜色、深度缓冲、进行混合等</p><ul><li>这一步进行逐片元输出合并操作</li><li>1.决定每个片元的可见性。例如深度测试、模板测试等</li><li>2.如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中点的颜色进行合并</li><li>模板测试、深度测试都是高度可配置化的</li></ul></li><li><p>最后，进行合并</p><ul><li>混合操作</li></ul></li></ul></li></ul></li></ul><h3 id="额外一些补充信息"><a href="#额外一些补充信息" class="headerlink" title="额外一些补充信息"></a>额外一些补充信息</h3><ul><li><p>有关OpenGL/DirectX</p><ul><li>是图像应用编程接口，这些接口用于渲染二维或三维图形。他们将各自的函数调用翻译成了GPU能听懂的语言。同时也是他们负责把纹理等数据转换成GPU所支持的格式</li><li>应用程序运行在CPU上，应用程序可以通过调用OpenGL或DirectX的图形接口将渲染所需的数据，如顶点数据，纹理数据，材质参数等数据存储在显存中的特定区域。</li><li>随后，开发者可通过图像编程接口发出渲染命令，这些渲染命令也被成为DrawCall，他们会被显卡驱动程序翻译成GPU能够理解的代码，进行真正的绘制。</li></ul></li><li><p>有关HLSL、GLSL、CG</p><ul><li><p>都是高级语言，专门用于编写着色器的着色语言</p></li><li><p>GLSL</p><ul><li>优点在于其跨平台性，openGL没有提供着色器编译器，交给了显卡驱动来完成。编译结果取决于硬件供应商</li></ul></li><li><p>HLSL</p><ul><li>微软控制着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的。</li></ul></li><li><p>CG</p><ul><li>真正意义上的跨平台，根据平台的不同，编译成相应的中间语言，语法和HLSL很像，可以无缝移植HLSL，但无法完全发挥出OpenGL的最新特性</li></ul></li></ul></li><li><p>有关DrawCall与Unity中的Batches</p><ul><li>Unity中通过减少批处理的形式降低DC</li><li>在游戏开发过程中，避免使用大量很小的网格，如果必需，考虑是否可以合并他们</li><li>避免使用过多的材质，尽量在不同的网格之间共用一个材质</li></ul></li><li><p>固定管线渲染</p><ul><li>指在较旧的GPU上实现的渲染流水线，这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权。</li></ul></li></ul><h2 id="UnityShader基础"><a href="#UnityShader基础" class="headerlink" title="UnityShader基础"></a>UnityShader基础</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>1.材质和UnityShader</p><ul><li><p>材质需要结合Mesh或ParticleSystems使用</p></li><li><p>Shader是Unity提供了四种模板</p><ul><li><p>StandardSurfaceShader</p><ul><li>包含了光照模型的表面着色器模板</li></ul></li><li><p>UnitShader</p><ul><li>不包含光照（包含雾效）的基本顶点/片元着色器</li></ul></li><li><p>ImageEffectShader</p><ul><li>实现各种屏幕后处理效果模板</li></ul></li><li><p>ComputeShader</p><ul><li>产生一种特殊的shader文件，这类文件旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算</li></ul></li></ul></li></ul></li></ul><hr><h1 id="待更新中…"><a href="#待更新中…" class="headerlink" title="待更新中…"></a>待更新中…</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TA向 </tag>
            
            <tag> CG </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统导论</title>
      <link href="2021/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
      <url>2021/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统导论"><a href="#操作系统导论" class="headerlink" title="操作系统导论"></a>操作系统导论</h1><h2 id="第二章：操作系统介绍"><a href="#第二章：操作系统介绍" class="headerlink" title="第二章：操作系统介绍"></a>第二章：操作系统介绍</h2><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h3 id="基本目标：建立一些抽象概念"><a href="#基本目标：建立一些抽象概念" class="headerlink" title="基本目标：建立一些抽象概念"></a>基本目标：建立一些抽象概念</h3><h3 id="设计和实现操作系统的目标"><a href="#设计和实现操作系统的目标" class="headerlink" title="设计和实现操作系统的目标"></a>设计和实现操作系统的目标</h3><ul><li>提供高性能与最小化操作系统的开销</li><li>在应用程序之间以及在OS和应用程序之间提供保护</li><li>操作系统力求提供高度的可靠性与稳定性</li></ul><h2 id="第三章：虚拟化"><a href="#第三章：虚拟化" class="headerlink" title="第三章：虚拟化"></a>第三章：虚拟化</h2><h3 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h3><ul><li><p>抽象概念：进程</p><ul><li><p>时分共享资源技术</p><ul><li>通过让一个进程只运行一个时间片，然后切换到其他进程，OS提供存在多个虚拟CPU的假象</li><li>所谓的资源：例如CPU或网络链接可以被许多人共享</li></ul></li><li><p>空分共享资源技术</p><ul><li>磁盘空间是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件</li></ul></li><li><p>需要一些低级机制和一些高级智能</p></li><li><p>进程的抽象定义及其组成</p><ul><li><p>一个进程只是一个正在运行的程序</p></li><li><p>组成</p><ul><li><p>寄存器</p><ul><li><p>程序计数器(PC)</p><ul><li>告诉我们程序即将执行哪个指令</li></ul></li><li><p>栈指针和相关的帧指针</p><ul><li>管理函数参数栈、局部变量、返回地址</li></ul></li></ul></li><li><p>内存</p><ul><li>进程可以访问的内存（地址空间）</li></ul></li></ul></li></ul></li><li><p>进程基本API</p><ul><li><p>创建</p><ul><li>操作系统提供创建新进程的方法</li></ul></li><li><p>销毁</p><ul><li>强制销毁程序的接口</li></ul></li><li><p>等待</p><ul><li>等待进程停止运行</li></ul></li><li><p>其他控制</p><ul><li>暂停进程</li><li>恢复进程</li></ul></li><li><p>状态</p><ul><li>获取进程当前有关的状态信息</li></ul></li></ul></li><li><p>进程创建的进一步细节</p><ul><li>1.将代码和所有静态数据例如初始化变量加载到内存中，加载到进程的地址空间中。</li><li>2.在早期的操作系统中，加载过程尽早完成，即在运行之前全部完成。现代操作系统惰性（lazy）执行该过程，即在运行期间需要加载的代码或数据片段才会加载</li><li>3.为程序的运行时栈分配一些内存。（栈空间）存放局部变量、函数参数和返回地址</li><li>4.为程序的堆分配一些内存，数据结构需要堆</li><li>5.一些其他的初始化任务，比如I/O相关任务</li><li>6.OS启动该程序，并在入口处执行(Main()),这时候OS将CPU控制权转移到新创建的该进程中，从而程序开始执行</li></ul></li><li><p>进程的状态</p><ul><li><p>运行</p><ul><li>正在运行中</li></ul></li><li><p>就绪</p><ul><li>准备好运行，由于策略暂时不运行</li></ul></li><li><p>阻塞</p><ul><li>发起IO请求，被阻塞，因此此时其他进程可以使用CPU，例如发起对磁盘数据的加载，对网络包数据的加载等</li></ul></li><li><p>初始</p><ul><li>进程在创建时处于的状态</li></ul></li><li><p>最终</p><ul><li>已经退出但尚未清理的状态，通过返回码告诉父进程它可以清理这个正在结束的进程的所有相关的数据结构</li></ul></li></ul></li><li><p>上下文切换</p><ul><li>在进程的切换过程中，当前被阻塞的进程其寄存器上下文将保存其寄存器的内容到一个内存位置上，当恢复运行时再通过恢复这些寄存器的信息（将他们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程</li></ul></li></ul></li><li><p>机制：受限制直接执行（底层机制）</p><ul><li><p>需要解决的问题</p><ul><li>1.操作系统如何确保程序不做任何我们不希望它做的事情，同时仍然高效运行它</li><li>2.当我们运行一个进程时，操作系统如何让它停下来并切换到另外一个进程，从而实现虚拟化CPU所需的时分共享</li></ul></li><li><p>问题1：</p><ul><li>用户希望执行某种受限制的特权操作，怎么做？</li><li>硬件通过不同的执行模式来协助操作系统，用户模式与内核模式，并通过OS暴露给用户模式的接口来切换进入内核模式执行相应特权操作</li></ul></li><li><p>问题2：</p><ul><li>陷入内核模式时执行的trap指令，他如何知道OS运行哪些代码？（有无恶意等情况）</li><li>内核通过在启动时设置traptable来实现，当机器启动时它在内核模式下执行，因此可以根据需要自由配置机器硬件。</li></ul></li><li><p>问题3：</p><ul><li>如何在没有协作的情况下获得控制权？</li><li>利用时钟中断，OS重新获得控制权，此时可以根据策略进行进程的切换等</li></ul></li><li><p>问题4：</p><ul><li>如何保存和恢复上下文？</li><li>如果决定切换，OS就会执行一些底层代码，即所谓的上下文切换（为当前正在执行的程序将其寄存器的值保存到内核栈，为下一个却换的进程从其内核栈恢复值到寄存器）</li><li>内核在进入切换代码调用时是一个进程（被中断的那个进程的上下文），在返回时是另一个进程的上下文，当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程，至此上下文切换完成</li></ul></li></ul></li><li><p>进程调度（高级智能）</p><ul><li><p>关键：确定工作负载是构建调度策略的关键部分</p></li><li><p>调度指标的定义</p><ul><li>周转时间=完成时间-到达时间</li></ul></li><li><p>常见调度策略（周转时间考虑）</p><ul><li><p>先进先出（FIFO）</p><ul><li>先到先服务</li><li>会存在护航效应</li></ul></li><li><p>最短任务优先（SJF）</p><ul><li>耗时最短的任务最优先执行</li><li>当任务同时到达时，它是一个最优调度算法，但当任务是随时到达时，情况发生了变化，仔细思考这里的变化</li><li>上述问题是因为这里还是基于非抢占式的调度策略</li></ul></li><li><p>最短完成时间优先（STCF）</p><ul><li>向SJF添加抢占策略，即最短完成时间优先或抢占式最短完成时间优先</li><li>基于上一章节的时钟断点切换进程恢复与保存寄存器数据来执行</li></ul></li></ul></li><li><p>新的调度指标</p><ul><li>响应时间=首次运行-到达时间</li></ul></li><li><p>常见调度策略（响应时间考虑）</p><ul><li><p>轮转（RR）</p><ul><li>在一个时间片（或一个调度量子）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。反复此轮转过程，直到任务结束</li><li>时间片长度必须是时钟中断周期的倍数</li><li>这里需要考虑，太短的时间片长度带来了很迅速的响应速度，但是响应的提高了整体上下文切换所带来的消耗，因此在设计这里时需要摊销此消耗</li></ul></li></ul></li><li><p>以上策略结合I/O来思考</p><ul><li>当然基本所有程序都执行I/O否则没有任何输入的程序每次都会产生相同的输出，一个没有输出的程序其运行没有意义</li><li>调度程序显然要在工作发起I/O请求时做出决策，应该在发生I/O进程阻塞时调度安排另外的工作</li><li>同时还必须在I/O完成时做出决定。发生这种情况时会产生中断，操作系统运行并将发出I/O的进程从阻塞状态移回就绪状态。</li></ul></li><li><p>！调度：多级反馈队列（MLFQ）</p><ul><li><p>该策略需要解决两方面的问题</p><ul><li>1.优化周转时间</li><li>2.降低响应时间</li></ul></li><li><p>没有工作长度的先验知识，如何设计一个能同时减少周转时间和响应时间的调度策略？</p></li><li><p>基本规则</p><ul><li>1.有许多队列，每个队列有不同的优先级</li><li>2.任何时候，一个工作只能存在于一个队列中，该策略总是执行较高优先级的工作</li><li>3.每个队列中可能会有多个工作，因此具有同样的优先级，这时，我们对这些工作采取轮转调度策略。</li><li>4.关键就在于如何设置优先级</li></ul></li><li><p>MLFQ没有为每个工作制定不变的优先顺序，而是根据观察到的行为调整它的优先级。</p></li><li><p>运行规则</p><ul><li>1.如果A的优先级&gt;B的优先级，运行A</li><li>2.如果A、B同级，轮转运行A和B</li><li>3.工作进入系统时，放在最高优先级上</li><li>4。工作用完整个时间片后，降低其优先级。如果工作在其时间片内主动释放CPU，则优先级不变。</li><li>5.经过一段时间S，就将系统中所有工作重新加入最高优先级队列。（S要合理的设置，否则会产生饥饿或交互工作得不到合适的CPU时间比例）</li></ul></li></ul></li></ul></li></ul><h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><ul><li><p>抽象：地址空间</p><ul><li><p>因为保护、隔离等问题出现，操作系统需要提供一个易用的物理内存抽象，这个抽象叫地址空间</p></li><li><p>虚拟内存系统的目标</p><ul><li><p>1.透明</p><ul><li>程序不应该感知到内存被虚拟化的事实，程序的行为就好像它拥有自己的私有物理内存</li></ul></li><li><p>2.效率</p><ul><li>OS追求虚拟化尽可能高效，时间与空间皆高效，在实现这一步时，OS依赖于硬件的TLB功能</li></ul></li><li><p>3.保护</p><ul><li>OS确保进程收到保护，不受其他进程影响，OS本身也不会受进程影响，保护能够让我们在进程之间提供隔离的特性</li></ul></li></ul></li><li><p>常见问题</p><ul><li>忘记分配内存</li><li>没有分配足够多的内存</li><li>忘记初始化分配的内存</li><li>忘记释放内存</li><li>在用完之前释放内存</li><li>反复释放内存</li><li>错误的调用free</li></ul></li></ul></li><li><p>机制：地址转换</p><ul><li><p>利用基于硬件的地址转换，硬件对每次内存访问进行处理，将指令中的虚拟地址转换为数据实际存储的物理地址，因此在每次内存引用时，硬件都会及进行地址转换。</p></li><li><p>仅仅依靠硬件不足以实现虚拟内存，好需要OS在关键位置介入，设置好硬件，以便完成正确的转换，因此它必须管理内存</p><hr><h1 id="待更新中…"><a href="#待更新中…" class="headerlink" title="待更新中…"></a>待更新中…</h1></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
